import { readdirSync, readFileSync } from 'node:fs'
import path from 'node:path'

export const VALID_SEMAFORO = new Set(['RED', 'YELLOW', 'GREEN'])
export const VALID_FASE = new Set(['planned', 'in_progress', 'done'])

function readText(filePath) {
  return readFileSync(filePath, 'utf8')
}

function extractField(content, regex) {
  const match = content.match(regex)
  return match ? match[1].trim() : null
}

function parseSpecFile(filePath) {
  const content = readText(filePath)
  const fileName = path.basename(filePath)
  const idMatch = fileName.match(/^(\d+)-/)
  const id = idMatch ? idMatch[1] : '00'

  const titleLine = content.split('\n')[0] ?? ''
  const featureFromTitle = titleLine
    .replace(/^#\s*/, '')
    .replace(/^\d+\s*-\s*/, '')
    .replace(/^SDD\s*-\s*/i, '')
    .trim()

  const semaforo = extractField(content, /- Semáforo:\s*`?(RED|YELLOW|GREEN)`?/i)
  const fase = extractField(content, /- Fase:\s*`?(planned|in_progress|done)`?/i)
  const nextStep = extractField(content, /- Next Step:\s*(.+)/i)
  const updated = extractField(content, /- Updated:\s*([0-9]{4}-[0-9]{2}-[0-9]{2}\s+[0-9]{2}:[0-9]{2})/i)

  return {
    id,
    feature: featureFromTitle,
    semaforo: semaforo ? semaforo.toUpperCase() : null,
    fase: fase ? fase.toLowerCase() : null,
    nextStep,
    updated,
    filePath,
  }
}

function semaforoRank(value) {
  if (value === 'RED') return 0
  if (value === 'YELLOW') return 1
  if (value === 'GREEN') return 2
  return 3
}

export function listSpecFiles(rootDir) {
  const specsDir = path.join(rootDir, 'specs')
  return readdirSync(specsDir)
    .filter((name) => name.endsWith('.md'))
    .sort()
    .map((name) => path.join(specsDir, name))
}

export function parseSpecs(rootDir) {
  return listSpecFiles(rootDir).map(parseSpecFile)
}

export function validateSpecsContract(specRows) {
  const violations = []

  for (const row of specRows) {
    if (!row.semaforo || !VALID_SEMAFORO.has(row.semaforo)) {
      violations.push(`${row.filePath}: missing/invalid Semáforo (RED|YELLOW|GREEN)`)
    }
    if (!row.fase || !VALID_FASE.has(row.fase)) {
      violations.push(`${row.filePath}: missing/invalid Fase (planned|in_progress|done)`)
    }
    if (!row.nextStep || row.nextStep.length < 3) {
      violations.push(`${row.filePath}: missing Next Step`)
    }
    if (!row.updated) {
      violations.push(`${row.filePath}: missing Updated (YYYY-MM-DD HH:MM)`)
    }
    if ((row.semaforo === 'RED' || row.semaforo === 'YELLOW') && (!row.nextStep || row.nextStep.length < 3)) {
      violations.push(`${row.filePath}: RED/YELLOW requires actionable Next Step`)
    }
  }

  return violations
}

export function generateMasterTrackerContent(specRows, generatedAt) {
  const sorted = [...specRows].sort((a, b) => {
    const rankDiff = semaforoRank(a.semaforo) - semaforoRank(b.semaforo)
    if (rankDiff !== 0) return rankDiff
    return a.id.localeCompare(b.id)
  })

  const header = `# Master Tracker (Autogenerated)

> Source: \`specs/*.md\`
> Generated: ${generatedAt}
> Do not edit manually. Run \`just sync-master\`.

| Spec ID | Feature | Semáforo | Fase | Next Step | Last Updated |
|---|---|---|---|---|---|
`

  const rows = sorted
    .map((row) => {
      const next = (row.nextStep ?? '').replace(/\|/g, '/')
      return `| ${row.id} | ${row.feature} | ${row.semaforo ?? '-'} | ${row.fase ?? '-'} | ${next || '-'} | ${row.updated ?? '-'} |`
    })
    .join('\n')

  return `${header}${rows}\n`
}
